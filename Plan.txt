📘 KONTEKST PROJEKTU ARC (dla Cursor) — WERSJA ROZSZERZONA

---

👤 KIM JESTEM I KIM TY JESTEŚ

- Ja: programuję w Pythonie i R, znam też trochę C++. Mam solidne podstawy matematyczne i rozumiem, co robię.
- Mam pomysły (mam nadzieję, że niezłe), ale **piszę kod wolno i średniej jakości**.
- Ty: **masz być moim programistą**. Nie zgaduj, jeśli czegoś nie rozumiesz — pytaj.
- Jeśli trzeba, dostarczę pseudokod, szkic, algorytm — ale to ty piszesz kod, dobrze i z testami.
- Nie chwal mnie. Pomóż mi znaleźć najlepsze możliwe rozwiązanie.
- Testy regresyjne są **absolutnie obowiązkowe**. Każda zmiana ma być bezpieczna.
- Kod ma być czysty, zrozumiały i możliwy do rozwoju.

---

🧩 O CO CHODZI W ARC PRIZE (KAGGLE, 2025)

- Konkurs oparty na zbiorze ARC (Abstraction and Reasoning Corpus, François Chollet).
- Każde zadanie to przykład: wejście/wyjście w postaci 2D siatki liczb całkowitych.
- **Celem jest GENERALIZACJA** — system ma działać na zadaniach, których wcześniej nie widział.
- Wersja konkursowa działa w środowisku Kaggle:
  - Brak internetu
  - Ograniczony czas (20–30 min)
  - CPU-only, brak GPU
  - Model musi być samodzielny, lekki, wydajny

---

🎯 CEL NADRZĘDNY: GENERALIZACJA

Powtarzamy 3 razy:

1. **Najważniejszy cel to generalizacja.**
2. **Najważniejszy cel to generalizacja.**
3. **Najważniejszy cel to generalizacja.**

Nie interesuje nas rozwiązywanie znanych zadań przez dopasowanie.
Chcemy systemu, który po przeanalizowaniu 50 zadań potrafi rozwiązać 200.
To oznacza: opis semantyczny, modularny, kompozycyjny.

---

🧠 MÓJ OGÓLNY PLAN (ramowy, rozwijany w trakcie)

1. Obiektowa percepcja:
- wykrywanie obiektów i ich cech (kolor, bbox, area, dziury, symetria, relacje, itd, itp, to otwarta lista).

2. Semantyczny DSL:
- zestaw ogólnych operacji np. rotate(obj), paint_inside(obj), itd itp to otwarta lista
- DSL musi być testowalny, rozszerzalny, kompozycyjny.

3. Warstwa heurystyczna:
- porównania input/output na poziomie obiektów i ich cech, itd itp to otwarta lista
- analiza różnic, propozycje transformacji.

4. Użycie LLM (lokalnego):
- nie generuje kodu ani outputów,
- otrzymuje: opis obiektów, różnice, dostępne operacje,
- ma zaproponować: strategię, sekwencję operacji lub nową operację.

5. Search:
- beam search, DFS lub inny planista symboliczny,
- priorytet operacji wskazanych przez heurystyki lub LLM.

6. Fallback:
- brute-force lub losowe wariacje w ograniczonym zakresie,
- Generowanie nowych operacji dsl przez LLM na podstawie: opis obiektów, różnice, dostępne operacje,
i widzą że się nie udało jak dotąd, tylko jeśli wszystko inne zawiedzie, z walidacją i testem regresyjnym.
LLm może dodać głupoty, po tym kroku trzeb się dna 100% upewnić że wszytsko dalej działa.

---

⚠️ CO ZE STARYM KODEM?

- Plik `arc_agi_system.py` rozwiązuje 26 zadań, ale jest całkowicie **nieprzydatny do generalizacji**.
- Zawiera ręcznie dopasowane operacje i twarde if-else – nie ma kompozycji, nie ma logiki semantycznej.
- Traktujemy go jako **antyprzykład**. Nie rozwijamy go. Nie refaktorujemy.
- Używamy go jedynie jako punkt odniesienia — **czego unikać**.

---

📁 STRUKTURA PROJEKTU

ARC/
├── arc_agi_system.py
│   - STARY KOD — do analizy błędów projektowych, NIE DO UŻYCIA
│
├── arc_agi_solver.py
│   - NOWY KOD — miejsce na semantyczny DSL, reguły, heurystyki, search
│
├── task_viewer.py
│   - Moduł do przeglądania zadań (wizualizacja + zapis TXT/PNG)
│
├── dane/
│   ├── arc-agi_training_challenges.json
│   └── arc-agi_training_solutions.json
│
└── task_views/
    ├── png/    (wizualizacje graficzne)
    └── text/   (reprezentacje tekstowe)

---

🧷 ZASADY PRACY

- Iteracyjnie, bezpiecznie, z pełną kontrolą.
- Każdy pomysł jest domyślnie podejrzany — zanim zostanie zakodowany, musi przejść analizę.
- **Lepiej nie mieć rozwiązania niż mieć złe.**
- Kod, który nie generalizuje — nie przechodzi.
- **Zawsze robimy testy regresyjne. Co działało — musi dalej działać.**
- Kod ma być możliwy do rozszerzania i testowania.